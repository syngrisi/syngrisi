## Задача: удаление осиротевших бейзлайнов

### Что считаем осиротевшим
- Бейзлайн, чей `snapshootId` не встречается ни в одном `Check.baselineId` (учет `realBaselineId` не требуется, поле не используется).
- Снимок может существовать физически; задача работает только с записями бейзлайнов (удаление файлов отдельно).

### Интерфейс и ручка
- Новая ручка: `GET /v1/tasks/task_handle_orphan_baselines?dryRun=true|false`.
- Доступ: те же требования, что к остальным админ-задачам (логин + роль admin).
- UI: пункт в Admin Panel → Tasks → “Handle Orphan Baselines” с чекбоксом `Dry run` (по умолчанию включен).

### Поведение
- **Dry run (по умолчанию)**: считает количество всех бейзлайнов и осиротевших, выводит первые 10 `_id`/`name`, ничего не удаляет.
- **Execute (dryRun=false)**: те же шаги статистики, затем батчевое удаление найденных бейзлайнов. Счётчик удаленных и итоговый остаток.
- Вывод ведётся через `HttpOutputWriter` построчно, чтобы UI видел прогресс.

### Алгоритм
1. Получить набор `snapshootId` всех бейзлайнов.
2. Найти уникальные `baselineId` в коллекции `Check` (через `distinct`) и построить `Set` используемых снимков.
3. Определить список осиротевших бейзлайнов (`snapshootId` не в Set).
4. Статистика + (опционально) удаление `Baseline.deleteMany({ _id: { $in: orphanIds } })` партиями.

### Проверки
- Unit через моки моделей: dry run не трогает данные; execute удаляет нужные элементы и пишет ожидаемые строки в `MockOutputWriter`.
- Ручная: запустить task с dryRun=true/false на тестовой БД, убедиться что прогресс и итоговое число совпадают, файлы снимков не трогаются.
